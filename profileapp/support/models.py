from django.db import models
# Create your models here.
from django.apps import apps
from django.utils.timezone import now


class SupportTicket(models.Model):
    STATUS_CHOICES = [
        ('open', 'Open'),
        ('in_progress', 'In Progress'),
        ('closed', 'Closed'),
    ]
    
    user = models.ForeignKey('profiling.Account', on_delete=models.CASCADE)
    subject = models.CharField(max_length=255)
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='open')
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        ordering = ['-created_at']
    
    def __str__(self):
        return f"Ticket {self.id} - {self.subject}"
    
class Message(models.Model):
    ticket = models.ForeignKey(SupportTicket, related_name='messages', on_delete=models.CASCADE)
    sender = models.ForeignKey('profiling.Account', on_delete=models.CASCADE, null=True, blank=True)  # Use string notation
    message = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)
    is_read = models.BooleanField(default=False)  # New field to track read status

    class Meta:
        ordering = ['created_at']  # Messages will be ordered by their creation time, oldest to newest

    def save(self, *args, **kwargs):
        """
        Override the save method to handle sending an automated response 
        if the first message is sent by a non-admin.
        """
        is_new_message = self.ticket.messages.count() == 0  # Check if it's the first message
        super().save(*args, **kwargs)  # Save the initial message first

        # If it's the first message and the sender is not a staff/admin
        if is_new_message and self.sender and not self.sender.is_staff:
            # Dynamically fetch the Account model
            Account = apps.get_model('profiling', 'Account')
            staff_user = Account.objects.filter(is_staff=True).first()

            if staff_user:
                # Automatically create a reply message from a staff account
                Message.objects.create(
                    ticket=self.ticket,
                    sender=staff_user,
                    message="Thank you for reaching out. A representative will get back to you within 1-3 business days. (This is an autogenerated message)"
                )
            else:
                raise ValueError("No staff user found to send the automated message.")
            
        if self.sender != self.ticket.user:
            Notification.objects.create(
                user=self.ticket.user,
                notification_type='support_ticket',
                support_ticket=self.ticket,
                message=f"A new message was added to your support ticket: '{self.ticket.subject}'."
            )

        self.ticket.updated_at = now()
        self.ticket.save()


    def mark_as_read(self, user):
        """
        Mark the me
        ssage as read if the given user is not the sender.
        Otherwise, do not allow the sender to mark the message as read.
        """
        if self.sender != user:
            if not self.is_read:
                self.is_read = True
                self.save()
        else:
            self.is_read = False
            self.save()

    def __str__(self):
        """
        String representation of the message, showing the sender and ticket ID.
        """
        return f"Message {self.id} by {self.sender.username} on Ticket {self.ticket.id}"

class Notification(models.Model):
    NOTIFICATION_TYPES = (
        ('announcement', 'Announcement'),
        ('event', 'Event'),
        ('support_ticket', 'Support Ticket'),
        ('profile', 'Profile Update'),  # âœ… New type
    )
    
    user = models.ForeignKey('profiling.Account', on_delete=models.CASCADE, related_name='notifications')
    notification_type = models.CharField(max_length=20, choices=NOTIFICATION_TYPES)
    
    # Foreign keys for different types of notifications
    announcement = models.ForeignKey('events.Announcement', on_delete=models.CASCADE, null=True, blank=True, related_name='notifications')
    event = models.ForeignKey('events.Event', on_delete=models.CASCADE, null=True, blank=True, related_name='notifications')
    support_ticket = models.ForeignKey(SupportTicket, on_delete=models.CASCADE, null=True, blank=True, related_name='notifications')
    
    message = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)
    is_read = models.BooleanField(default=False)    

    def mark_as_read(self):
        self.is_read = True
        self.save()

    def __str__(self):
        if self.notification_type == 'announcement' and self.announcement:
            return f"Announcement: {self.announcement.title} - {self.user.username}"
        elif self.notification_type == 'event' and self.event:
            return f"Event: {self.event.title} - {self.user.username}"
        elif self.notification_type == 'support_ticket' and self.support_ticket:
            return f"Support Ticket: {self.support_ticket.subject} - {self.user.username}"
        else:
            return f"Notification for {self.user.username}"
